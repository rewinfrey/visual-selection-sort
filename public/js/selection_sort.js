// Generated by CoffeeScript 1.3.3
(function() {
  var Animate, LinkedList, Node, SelectionSort;

  SelectionSort = (function() {

    function SelectionSort(canvas_height, canvas_width, stroke) {
      this.canvas_height = canvas_height;
      this.canvas_width = canvas_width;
      this.stroke = stroke;
      this.data = [];
      this.sorted = [];
      this.animation_list = new LinkedList();
      this.canvas_height = this.canvas_height;
      this.canvas_width = this.canvas_width;
      this.stroke = this.stroke;
    }

    SelectionSort.prototype.construct_array = function() {
      var _results;
      _results = [];
      while (this.data.length < (parseInt(this.canvas_width / this.stroke))) {
        _results.push(this.data.push(new Node(this.data.length, parseInt((Math.random() * 1000 % this.canvas_height - 50) + 50))));
      }
      return _results;
    };

    SelectionSort.prototype.first_unsorted_index = function() {
      var element, index, _i, _len, _ref;
      _ref = this.data;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        element = _ref[index];
        if (element.state === "unsorted") {
          return index;
        }
      }
      return null;
    };

    SelectionSort.prototype.swap_elements = function(minimum) {
      var first, first_y;
      first = this.first_unsorted_index();
      first_y = this.data[first].y;
      this.animation_list.add_animation_node(this.data[first], "swap");
      this.animation_list.add_animation_node(this.data[minimum], "swap");
      this.animation_list.add_animation_node(this.data[first], "swap");
      this.animation_list.add_animation_node(this.data[minimum], "swap");
      this.data[first].y = this.data[minimum].y;
      this.data[minimum].y = first_y;
      this.data[first].state = "sorted";
      this.animation_list.add_animation_node(this.data[first], "swap");
      this.animation_list.add_animation_node(this.data[minimum], "swap");
      this.animation_list.add_animation_node(this.data[first], "swap");
      this.animation_list.add_animation_node(this.data[minimum], "swap");
      if (minimum === first) {
        return this.animation_list.add_animation_node(this.data[first], "sorted");
      } else {
        this.animation_list.add_animation_node(this.data[minimum], "unsorted");
        return this.animation_list.add_animation_node(this.data[first], "sorted");
      }
    };

    SelectionSort.prototype.selection_sort = function() {
      var element, index, minimum, _i, _len, _ref;
      minimum = this.first_unsorted_index();
      if (minimum !== null) {
        this.animation_list.add_animation_node(this.data[minimum], "minimum");
        _ref = this.data;
        for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
          element = _ref[index];
          if (element.state !== "sorted") {
            if (index !== minimum) {
              this.animation_list.add_animation_node(this.data[index], "iteration");
              this.animation_list.add_animation_node(this.data[index], "unsorted");
            }
            if (element.y < this.data[minimum].y) {
              this.animation_list.add_animation_node(this.data[minimum], "unsorted");
              this.animation_list.add_animation_node(this.data[index], "minimum");
              minimum = index;
            }
          }
        }
        this.swap_elements(minimum);
        return this.selection_sort();
      } else {

      }
    };

    return SelectionSort;

  })();

  Node = (function() {

    function Node(x, y) {
      this.x = x;
      this.y = y;
      this.x = this.x;
      this.y = this.y;
      this.prev = null;
      this.next = null;
      this.state = "unsorted";
    }

    Node.prototype.copy = function() {
      var temp_node;
      temp_node = new Node(this.x, this.y);
      temp_node.prev = this.prev;
      temp_node.next = this.next;
      return temp_node;
    };

    return Node;

  })();

  LinkedList = (function() {

    function LinkedList() {
      this.first = null;
      this.last = null;
      this.length = 0;
      this.max = 0;
    }

    LinkedList.prototype.selection_sort_swap = function(min, sorted_list, animation_list) {
      var length, node;
      length = 0;
      node = this.first;
      while (length < this.length) {
        if (min.x === node.x && min.y === node.y) {
          animation_list.add_animation_node(this.first, "swap");
          animation_list.add_animation_node(min, "swap");
          min.y = this.first.y;
          this.first.y = node.y;
          animation_list.add_animation_node(this.first, "swapped");
          animation_list.add_animation_node(min, "swapped");
          animation_list.add_animation_node(this.first, "unsorted");
          animation_list.add_animation_node(min, "unsorted");
          return;
        }
        node = node.prev;
        length += 1;
      }
    };

    LinkedList.prototype.remove_node = function(node) {
      if (this.length > 1) {
        if (node === this.first) {
          this.first = node.prev;
        }
        if (node === this.last) {
          this.last = node.next;
        }
      } else {
        this.first = null;
        this.last = null;
      }
      return this.length -= 1;
    };

    LinkedList.prototype.add_node = function(node) {
      if (this.length === 0) {
        node.prev = node;
        node.next = node;
        this.first = node;
        this.last = node;
      } else {
        this.first.next = node;
        this.last.prev = node;
        node.prev = this.first;
        node.next = this.last;
        this.last = node;
      }
      return this.length += 1;
    };

    LinkedList.prototype.is_empty = function() {
      return this.length === 0;
    };

    LinkedList.prototype.add_animation_node = function(node, state) {
      var temp_node;
      temp_node = new Node(node.x, node.y);
      temp_node.state = state;
      return this.add_node(temp_node);
    };

    return LinkedList;

  })();

  Animate = (function() {

    function Animate(id, canvas_height, canvas_width, stroke, frame_rate) {
      this.id = id;
      this.canvas_height = canvas_height;
      this.canvas_width = canvas_width;
      this.stroke = stroke;
      this.frame_rate = frame_rate;
      this.ctx = document.getElementById("" + this.id).getContext("2d");
      this.height = this.canvas_height;
      this.width = this.canvas_width;
      this.stroke = this.stroke;
      this.list_size = 0;
      this.frame_rate = this.frame_rate;
    }

    Animate.prototype.reset_canvas = function() {
      return this.ctx.clearRect(0, 0, this.height, this.width);
    };

    Animate.prototype.get_list_size = function(linked_list) {
      return this.list_size = linked_list.length;
    };

    Animate.prototype.draw_linked_list = function(linked_list) {
      var current_node, length, _results;
      length = 0;
      current_node = linked_list.first;
      _results = [];
      while (length < linked_list.length) {
        this.ctx.clearRect(current_node.x * this.stroke, 0, this.stroke, this.height);
        this.ctx.fillStyle = "rgb(45,123,200)";
        this.ctx.fillRect(current_node.x * this.stroke, this.height - current_node.y, this.stroke, current_node.y);
        current_node = current_node.prev;
        _results.push(length += 1);
      }
      return _results;
    };

    Animate.prototype.draw_array = function(array) {
      var element, element_index, _i, _len, _results;
      _results = [];
      for (element_index = _i = 0, _len = array.length; _i < _len; element_index = ++_i) {
        element = array[element_index];
        this.ctx.clearRect(element.x * this.stroke, 0, this.stroke, this.height);
        this.ctx.fillStyle = "rgb(45,123,200)";
        _results.push(this.ctx.fillRect(element.x * this.stroke, this.height - element.y, this.stroke, element.y));
      }
      return _results;
    };

    Animate.prototype.draw_frame = function(current_node) {
      switch (current_node.state) {
        case "unsorted":
          this.ctx.clearRect(current_node.x * this.stroke, 0, this.stroke, this.height);
          this.ctx.fillStyle = "rgb(45,123,200)";
          return this.ctx.fillRect(current_node.x * this.stroke, this.height - current_node.y, this.stroke, current_node.y);
        case "sorted":
          this.ctx.clearRect(current_node.x * this.stroke, 0, this.stroke, this.height);
          this.ctx.fillStyle = "rgb(255,153,0)";
          return this.ctx.fillRect(current_node.x * this.stroke, this.height - current_node.y, this.stroke, current_node.y);
        case "swap":
          this.ctx.clearRect(current_node.x * this.stroke, 0, this.stroke, this.height);
          this.ctx.fillStyle = "rgb(200,0,0)";
          return this.ctx.fillRect(current_node.x * this.stroke, this.height - current_node.y, this.stroke, current_node.y);
        case "swapped":
          this.ctx.clearRect(current_node.x * this.stroke, 0, this.stroke, this.height);
          this.ctx.fillStyle = "rgb(200,150,0)";
          return this.ctx.fillRect(current_node.x * this.stroke, this.height - current_node.y, this.stroke, current_node.y);
        case "iteration":
          this.ctx.clearRect(current_node.x * this.stroke, 0, this.stroke, this.height);
          this.ctx.fillStyle = "rgb(255,255,0)";
          return this.ctx.fillRect(current_node.x * this.stroke, this.height - current_node.y, this.stroke, current_node.y);
        case "minimum":
          this.ctx.clearRect(current_node.x * this.stroke, 0, this.stroke, this.height);
          this.ctx.fillStyle = "rgb(100,200,100)";
          return this.ctx.fillRect(current_node.x * this.stroke, this.height - current_node.y, this.stroke, current_node.y);
        default:
          this.ctx.clearRect(current_node.x * this.stroke, 0, this.stroke, this.height);
          this.ctx.fillStyle = "rgb(45,123,200)";
          return this.ctx.fillRect(current_node.x * this.stroke, this.height - current_node.y, this.stroke, current_node.y);
      }
    };

    Animate.prototype.process_animation = function(animation_list) {
      var new_frame,
        _this = this;
      if (animation_list.length !== 0) {
        new_frame = new Node(animation_list.first.x, animation_list.first.y);
        new_frame.state = animation_list.first.state;
        this.draw_frame(new_frame);
        animation_list.remove_node(animation_list.first);
        return window.setTimeout(function() {
          return _this.process_animation(animation_list);
        }, this.frame_rate);
      }
    };

    return Animate;

  })();

  $(document).ready(function() {
    var animate, animation_list, canvas_height, canvas_width, frame_rate, selection, sorted_list, stroke;
    frame_rate = 75;
    stroke = 35;
    canvas_height = parseInt($('#selection_sort').css('height').replace("px", ""));
    canvas_width = parseInt($('#selection_sort').css('width').replace("px", ""));
    animate = new Animate("selection_sort", canvas_height, canvas_width, stroke, frame_rate);
    selection = new SelectionSort(canvas_height, canvas_width, stroke);
    sorted_list = new LinkedList();
    animation_list = new LinkedList();
    selection.construct_array();
    animate.draw_array(selection.data);
    selection.selection_sort();
    return animate.process_animation(selection.animation_list);
  });

}).call(this);
